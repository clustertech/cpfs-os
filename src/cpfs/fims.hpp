#pragma once

/* Copyright 2013 ClusterTech Ltd */

/**
 * @file
 *
 * Define concrete Fim object classes.
 *
 * The convention of Fim classes in this file is: all Fim classes are
 * named with Fim suffix, like XxxFim.  It always has a part which
 * type is named like XxxFimPart, which might be a typedef (possibly
 * to void).  With these conventions, the DEFINE_FIM_CLASS_VOID,
 * DEFINE_FIM_CLASS_ALIAS and DEFINE_FIM_CLASS_STRUCT macros are used
 * to create the actual Fim class.  A constant is created by the
 * macro, named like kXxxFim, to denote the type code of the Fim.
 *
 * For interoperatability, structures defined here needs to have the
 * same bit representation (except tail padding) when compiled in a
 * 32-bit and 64-bit platforms.  We also take care to maintain that
 * all fields are aligned.  This means we should usually arrange
 * fields from large to small.  Finally, we use an end-marker to
 * detect the size of the Fim part if they are not void.  Previously
 * this has been handled by sizeof(), but that would include bytes
 * padded by the compiler in the end of the structure, which needs
 * painful initialization to make valgrind happy.  We could stop the
 * compiler from such padding using __attribute__(__packed__), but
 * that has bad side effects because the compiler stops assuming that
 * the struct is correctly aligned.
 *
 * Fim types of code 1000 and above are dispatched to the Worker's
 * according to the first 64 bits, which is always an InodeNum.  The
 * thread used for that inode is called the "designated thread" of the
 * inode.  The design aims to provide the following guarantees:
 *
 * * For files, it guarantees that the inode attributes (apart from
 *   ctime and nlink) and contents stored in the data directory will
 *   be modified only by the designated thread of the inode.  A new
 *   inode may be created in a thread different from its designated
 *   thread, however.  E.g., Setattr, Write and Truncate is done in
 *   the designated thread of the inode, while Link, Rename and Unlink
 *   of an inode file are not.
 *
 * * For directories, it guarantees that in the data directory,
 *   directory entries pointing to inodes are created / modified only
 *   by the designated inode of the directory holding the entry.
 *   Removal may be done by a different thread, though.  So if the
 *   designated thread of a directory inode finds a directory entry
 *   pointing to inode a, it can safely assume that the directory
 *   entry will not be modified to a different inode b, although it
 *   could disappear altogether.  E.g., Create, Symlink, Link and
 *   Unlink are all done in the designated thread of the directory
 *   being operated on.  Rename is done in the designated thread of
 *   the target (not source) directory.
 */

#include <stddef.h>
#include <stdint.h>

#include <cstring>
#include <stdexcept>

#include <boost/scoped_array.hpp>
#include <boost/type_traits/is_void.hpp>  // IWYU pragma: export
#include <boost/utility/enable_if.hpp>  // IWYU pragma: export
// IWYU pragma: no_include "boost/utility/enable_if.hpp"

#include "common.hpp"
#include "fim.hpp"
#include "finfo.hpp"
#include "intrusive_util.hpp"

#ifndef FIMS_DEF_HOOK

/**
 * Add additional definitions for each Fim class if this is defined
 */
#define FIMS_DEF_HOOK(cls)

#endif

namespace cpfs {

/** The flag for Reply Fim */
const uint8_t kFimFlagReply = 1;

/**
 * Partial implementation for the IFim interface.  The purpose of the
 * class is to provide a common implementation for methods that are
 * just the same for all Fim object types, so as to reduce the amount
 * of code generated by each instantiation of the BaseFim template.
 */
class AbstractFim : public IFim {
 public:
  const char* msg() const { return msg_.get(); }
  uint32_t len() const { return fim_head()->len; }
  FimType type() const { return fim_head()->type & ~0x8000; }
  bool is_final() const { return fim_head()->type & 0x8000; }
  void set_final(bool final = true) {
    if (final)
      fim_head()->type |= 0x8000;
    else
      fim_head()->type &= ~0x8000;
  }
  ReqId req_id() const { return fim_head()->req_id; }
  void set_req_id(ReqId req_id) { fim_head()->req_id = req_id; }
  uint16_t protocol() const { return fim_head()->protocol; }
  char* body() { return msg_.get() + sizeof(FimHead); }
  uint32_t body_size() const { return len() - sizeof(FimHead); }

 protected:
  /**
   * Constructor.  It takes care to put content to the header to
   * initialize the FIM.  The request id is set to 0, meaning it is
   * not part of a request.  The set_req_id() method may be called to
   * change this.
   *
   * @param size The size of the FIM.
   *
   * @param type The type of the FIM.
   */
  AbstractFim(uint32_t size, FimType type) {
    msg_.reset(new char[size]);
    FimHead* head = fim_head();
    head->req_id = 0;
    head->len = size;
    head->type = type;
    head->protocol = 0x0001;
  }

  /**
   * Copy constructor.  The whole message is copied, including the
   * request ID.
   *
   * @param other The Fim object to copy.
   */
  AbstractFim(const AbstractFim& other) : IFim() {
    if (&other != this) {
      msg_.reset(new char[other.len()]);
      std::memcpy(msg_.get(), other.msg(), other.len());
    }
  }

  /**
   * Construct a Fim object by adopting raw message data.  The caller
   * is responsible for ensuring that the message contains the right
   * content and has the right size.
   *
   * @param data The raw message data.  After the call, it is owned by
   * the Fim
   */
  explicit AbstractFim(char* data) {
    msg_.reset(data);
  }

  /**
   * Gets the FIM head.
   */
  FimHead* fim_head() { return reinterpret_cast<FimHead*>(msg_.get()); }
  /**
   * Gets the FIM head, for const Fim object.
   */

  const FimHead* fim_head() const {
    return reinterpret_cast<FimHead*>(msg_.get());
  }

  boost::scoped_array<char> msg_; /**< Store the FIM message. */
};

/** @cond */
template<typename T>
inline int Size_() {
  return offsetof(T, end_padding);
}

template<>
inline int Size_<void>() {
  return 0;
}
/** @endcond */

/**
 * Concrete Fim object template class.
 *
 * @tparam TPart The structure containing type-specific part of the
 * FIMs being represented, other than the tail buffer.
 *
 * @tparam CFimType The FIM type that the Fim object is good for.
 * @tparam CFimFlag The FIM flag. Non reply FIM by default.
 */
template<typename TPart, FimType CFimType, uint8_t CFimFlag = 0>
class BaseFim : public AbstractFim {
 public:
  /**
   * The structure containing type-specific part of the FIMs being
   * represented, other than the tail buffer.
   */
  typedef TPart PartType;

  /**
   * Shorthand for the full type.
   */
  typedef BaseFim<TPart, CFimType, CFimFlag> TFim;

  /**
   * The FIM type that the Fim object is good for.
   */
  static const int kFimType = CFimType;

  /**
   * @return The difference between len() and tail_buf_size()
   */
  static uint32_t TailSizeDiff() {
    return sizeof(FimHead) + Size_<TPart>();
  }

  /**
   * Constructs a Fim object of the type, with a specified tail buffer
   * size.  The FIM head is initialized, except that the request ID is
   * left unset.
   *
   * @param tail_buf_size The size of the tail buffer.
   */
  explicit BaseFim(uint32_t tail_buf_size = 0)
      : AbstractFim(TailSizeDiff() + tail_buf_size, CFimType) {}

  /**
   * Copies a Fim object of the type.
   *
   * @param other The Fim object to copy from.
   */
  explicit BaseFim(const TFim& other) : AbstractFim(other) {}

  /**
   * Construct a Fim object by adopting raw message data.
   *
   * @param data The raw message data.
   */
  explicit BaseFim(char* data) : AbstractFim(data) {}

  /**
   * Assigns the content of a Fim object to another.
   *
   * @param other The Fim object to assign from.
   */
  TFim& operator=(const TFim& other) {
    BaseFim<TPart, CFimType> built(other);
    msg_.swap(built.msg_);
    return *this;
  }

  /**
   * Gets type-specific fields of the Fim object.  The Fim object act
   * likes a smart-pointer of TPart: any field of the Fim-specific
   * part can be accessed using fim->field (while the generic fields
   * in the Fim header is accessed using fim.field).
   */
  TPart* operator->() {
    return reinterpret_cast<TPart*>(msg_.get() + sizeof(FimHead));
  }

  /**
   * Gets type-specific fields of the Fim object.  The Fim object act
   * likes a smart-pointer of TPart: any field of the Fim-specific
   * part can be accessed using fim->field (while the generic fields
   * in the Fim header is accessed using fim.field).
   */
  const TPart* operator->() const {
    return reinterpret_cast<const TPart*>(msg_.get() + sizeof(FimHead));
  }

  /**
   * Whether this is a reply Fim
   */
  bool IsReply() const {
    return CFimFlag == kFimFlagReply;
  }

  const char* tail_buf() const {
    return msg_.get() + TailSizeDiff();
  }

  char* tail_buf() {
    return msg_.get() + TailSizeDiff();
  }

  uint32_t tail_buf_size() const {
    return len() - TailSizeDiff();
  }

  void tail_buf_resize(uint32_t new_size) {
    uint32_t old_size = tail_buf_size();
    uint32_t old_len = fim_head()->len;
    uint32_t new_len = old_len + new_size - old_size;
    if (old_len < new_len) {
      boost::scoped_array<char> new_msg(new char[new_len]);
      std::memcpy(new_msg.get(), msg(), old_len);
      msg_.swap(new_msg);
    }
    fim_head()->len = new_len;
  }

  /**
   * Make a new empty instance in a shared pointer.
   *
   * @param tail_buf_size The tail buffer size
   *
   * @return The shared pointer
   */
  static FIM_PTR<TFim> MakePtr(uint32_t tail_buf_size = 0) {
    return FIM_PTR<TFim>(new TFim(tail_buf_size));
  }

  /**
   * Create a Fim from raw data containing the FIM head.
   */
  static FIM_PTR<IFim> FromHead(const char* data) {
    const FimHead* head = reinterpret_cast<const FimHead*>(data);
    if (uint32_t(head->len - TailSizeDiff()) > uint32_t(1024 * 1024) ||
        head->protocol != 0x0001)
      throw std::runtime_error("Corrupted Fim");
    char* copy = new char[head->len];
    std::memcpy(copy, data, sizeof(FimHead));
    return FIM_PTR<IFim>(new TFim(copy));
  }

 protected:
  mutable SimpleRefCount<IFim> cnt_; /**< The counter object */

  /**
   * @return The counter object used
   */
  SimpleRefCount<IFim>* cnt() const {
    return &cnt_;
  }
};

/**
 * Gets type-specific fields of the Fim object.  The Fim object act
 * likes a smart-pointer of TPart: any field of the Fim-specific
 * part can be accessed using fim->field (while the generic fields
 * in the Fim header is accessed using fim.field).  This function is
 * generated only if TPart is not void.
 */
template<typename TFim>
typename boost::disable_if<
  boost::is_void<typename TFim::PartType>, typename TFim::PartType>::type&
operator*(TFim& fim) {  // NOLINT(runtime/references)
  return *(fim.operator->());
}

/**
 * Macro to define a Fim class where the FimPart is void.
 */
#define DEFINE_FIM_CLASS_VOID(code, name, flags)                    \
  DEFINE_FIM_CLASS_ALIAS(code, name, flags, void)

/**
 * Macro to define a Fim class aliasing other class as the FimPart.
 */
#define DEFINE_FIM_CLASS_ALIAS(code, name, flags, alias_from)       \
  typedef alias_from name ## Part;                                  \
  /** Fim type for name ## Part */                                  \
  DEFINE_FIM_CLASS(code, name, flags)

/**
 * Macro to define a Fim class by defining a struct as the FimPart.
 * After the macro call, it is expected that it follows a {, the
 * fields in the struct, a call to FIM_STRUCT_END with the same
 * arguments, and a }.  This arrangement makes the invocation code
 * easier to read.
 */
// "extern "C" {" is used to make closing brace after the
// FIM_STRUCT_END call correct, while keeping doxygen happy in
// accepting that the apidoc before the DEFINE_FIM_CLASS_STRUCT to be
// the doc of the struct rather than anything else.  The code and
// flags argument of this is not used here (only the ones in the END
// call is used), and only serves to make search easier.
#define DEFINE_FIM_CLASS_STRUCT(code, name, flags)                  \
  extern "C" { struct name ## Part

/**
 * End a DEFINE_FIM_CLASS_STRUCT definition.  Also adds the
 * end_padding field required for all FimPart structs.
 */
#define FIM_STRUCT_END(code, name, flags)                           \
    char end_padding[0]; /**< End marker */                         \
  };                                                                \
  /** Fim type for name ## Part */                                  \
  DEFINE_FIM_CLASS(code, name, flags);

/**
 * Macro to define a Fim class.
 */
#define DEFINE_FIM_CLASS(code, name, flags)                         \
  typedef BaseFim<name ## Part, code, flags> name;                  \
  const FimType k ## name = code; /**< Fim type for name */         \
  FIMS_DEF_HOOK(name);

/**
 * First request-reply Fim type.  FIM with ID higher than this always
 * starts with an InodeNum for worker dispatch.
 */
const int kMinReqReplyFimType = 1000;

/* ===== Generic non-request-response Fim's, type 1-49. ===== */

/**
 * Fim part for the heartbeat operation.
 */
DEFINE_FIM_CLASS_VOID(1, HeartbeatFim, 0);

/**
 * Fim part for indicating a Fim needs redirection to original DS as
 * the DSG is no longer degraded.
 */
DEFINE_FIM_CLASS_STRUCT(2, NotDegradedFim, 0) {
  ReqId redirect_req; /**< The request ID of the Fim to be redirected */
  FIM_STRUCT_END(2, NotDegradedFim, 0);
};

/**
 * Fim part for data recovery.
 */
DEFINE_FIM_CLASS_STRUCT(10, DataRecoveryFim, 0) {
  InodeNum inode; /**< The inode to recover data */
  uint64_t dsg_off; /**< DSG offset requiring recovery */
  FIM_STRUCT_END(10, DataRecoveryFim, 0);
};

/**
 * Fim part for data recovery.  The actual data is sent in the tail
 * buffer.  Note that it is not a reply to the RecoveryDataFim, even
 * though it is always sent in response to that.  This is a
 * technicality: the recovery data has to be processed in the DS
 * Worker thread assigned for the inode, and it is easiest if the Fim
 * is not a reply (otherwise it will be processed in the main thread).
 */
DEFINE_FIM_CLASS_STRUCT(11, RecoveryDataFim, 0) {
  InodeNum inode; /**< The inode of the recovery data */
  uint64_t dsg_off; /**< The DSG offset of the recovery data */
  uint32_t result; /**< 0 if successful, otherwise errno */
  FIM_STRUCT_END(11, RecoveryDataFim, 0);
};

/**
 * Fim part for resetting Fim defer manager.  This is an internal Fim
 * used by DS to reset the defer state.
 */
DEFINE_FIM_CLASS_STRUCT(12, DeferResetFim, 0) {
  uint64_t state_change_id; /**< State change ID triggering the Fim */
  FIM_STRUCT_END(12, DeferResetFim, 0);
};

/**
 * Fim part for connection initiator to send a challenge to initiate
 * authentication.
 */
DEFINE_FIM_CLASS_STRUCT(20, AuthMsg1Fim, 0) {
  Nonce nonce;  /**< The nonce */
  FIM_STRUCT_END(20, AuthMsg1Fim, 0);
};

/**
 * Fim part for listener to respond to challenge and send its own
 * challenge.  The response is sent in the tail buffer.
 */
DEFINE_FIM_CLASS_STRUCT(21, AuthMsg2Fim, 0) {
  Nonce nonce;  /**< The nonce */
  FIM_STRUCT_END(21, AuthMsg2Fim, 0);
};

/**
 * Fim part for connector to respond to challenge.  The response is
 * sent in the tail buffer.
 */
DEFINE_FIM_CLASS_VOID(22, AuthMsg3Fim, 0)

/**
 * Fim part for DS modification reversion.  This is an internal Fim,
 * and is never sent out of the server.  Actual data used are all kept
 * as WorkerMemo, and as such only the ID is passed.
 */
DEFINE_FIM_CLASS_STRUCT(40, RevertWriteFim, 0) {
  uint64_t memo_id; /**< The memo id */
  FIM_STRUCT_END(40, RevertWriteFim, 0);
};

/**
 * Fim part for DS distressed write completion notification.  This is
 * an internal Fim, and is never sent out of the server.
 */
DEFINE_FIM_CLASS_STRUCT(41, DistressedWriteCompletionFim, 0) {
  InodeNum inode; /**< The inode number */
  uint64_t segment; /**< The segment number */
  FIM_STRUCT_END(41, DistressedWriteCompletionFim, 0);
};

/**
 * Fim part for MS to request for attribute cleanup.  This is an
 * internal Fim, and is never sent out of the server.
 */
DEFINE_FIM_CLASS_STRUCT(50, InodeCleanAttrFim, 0) {
  InodeNum inode; /**< The inode number */
  uint64_t gen; /**< Generation number */
  FIM_STRUCT_END(50, InodeCleanAttrFim, 0);
};

/**
 * Fim part for notifying attribute update completion.  This is an
 * internal Fim used by MS to tell the appropriate MS worker thread to
 * update the file attributes if possible.  Though, it will be
 * forwarded to the slave MS, because the slave also need this
 * information to perform accounting of such entries correctly.
 */
DEFINE_FIM_CLASS_STRUCT(51, AttrUpdateCompletionFim, 0) {
  InodeNum inode; /**< The inode number */
  FSTime mtime; /**< Aggregated mtime of the inode */
  uint64_t size; /**< Aggregated file size of the inode */
  uint64_t gen; /**< Generation number where the update is triggered */
  FIM_STRUCT_END(20102, AttrUpdateCompletionFim, 0);
};

/* ===== Registration Fim's, type 100-499. ===== */

/**
 * Fim part for FC to register with MS.
 */
DEFINE_FIM_CLASS_STRUCT(100, FCMSRegFim, 0) {
  ClientNum client_num;  /**< Client number assigned, if FC is re-connecting */
  uint8_t is_reconnect;  /**< Is FC re-connecting for failover */
  uint8_t force_start;  /**< Whether to force the server to become active */
  char type;  /**< 'F' for FC, 'A' for Admin Client */
  uint16_t pid;  /**< The process ID */
  FIM_STRUCT_END(100, FCMSRegFim, 0);
};

/**
 * Fim part for MS to notify successful FC registration.
 */
DEFINE_FIM_CLASS_STRUCT(101, FCMSRegSuccessFim, 0) {
  ClientNum client_num; /**< The client num assigned by MS */
  FIM_STRUCT_END(101, FCMSRegSuccessFim, 0);
};

/**
 * Fim part for FC to register with DS.
 */
DEFINE_FIM_CLASS_STRUCT(110, FCDSRegFim, 0) {
  ClientNum client_num;  /**< The client number assigned by MS */
  FIM_STRUCT_END(110, FCDSRegFim, 0);
};

/**
 * Fim part for DS to register with MS.
 */
DEFINE_FIM_CLASS_STRUCT(120, DSMSRegFim, 0) {
  char uuid[40];  /**< Keep UUID hex in the first 36 bytes */
  GroupId ds_group; /**< The group id, set if group was assigned */
  GroupRole ds_role; /**< The role, starts from 0, set if group was assigned */
  uint32_t ip; /**< The ipv4 address for DS/FC to connect */
  uint16_t port; /**< The port listening on */
  uint16_t pid;  /**< The process ID */
  uint8_t is_grouped; /**< Whether DS was assigned group */
  uint8_t is_reconnect; /**< Is DS re-connecting for failover */
  uint8_t opt_resync; /**< Whether optimized resync is possible */
  uint8_t distressed; /**< Whether distressed mode is set */
  FIM_STRUCT_END(120, DSMSRegFim, 0);
};

/**
 * Fim part for MS to notify successful DS registration.
 */
DEFINE_FIM_CLASS_STRUCT(121, DSMSRegSuccessFim, 0) {
  GroupId ds_group;  /**< The group id assigned by MS*/
  GroupRole ds_role;  /**< The role assigned by MS, starts from 0 */
  FIM_STRUCT_END(121, DSMSRegSuccessFim, 0);
};

/**
 * Fim part for DS to register with a peer DS.
 */
DEFINE_FIM_CLASS_STRUCT(130, DSDSRegFim, 0) {
  GroupId ds_group;  /**< The group id assigned by MS*/
  GroupRole ds_role;  /**< The role assigned by MS, starts from 0 */
  FIM_STRUCT_END(130, DSDSRegFim, 0);
};

/**
 * Fim part for MS to register with MS.
 */
DEFINE_FIM_CLASS_STRUCT(140, MSMSRegFim, 0) {
  char uuid[40];  /**< Keep UUID hex in the first 36 bytes */
  uint64_t ha_counter;  /**< The HA counter of the secondary MS. */
  uint8_t active; /**< Whether the server is already active. */
  char new_node;  /**< Whether the server was created before */
  FIM_STRUCT_END(140, MSMSRegFim, 0);
};

/**
 * Fim part for MS to notify successful MS registration.
 */
DEFINE_FIM_CLASS_STRUCT(141, MSMSRegSuccessFim, 0) {
  char uuid[40];  /**< Keep UUID hex in the first 36 bytes */
  uint64_t ha_counter;  /**< The HA counter of the primary MS. */
  uint8_t active; /**< Whether the server is already active. */
  char new_node;  /**< Whether the server was created before */
  FIM_STRUCT_END(141, MSMSRegSuccessFim, 0);
};

/**
 * Fim part for rejecting MS connections in HA mode.
 */
DEFINE_FIM_CLASS_VOID(150, MSRegRejectedFim, 0)

/* ===== Cluster state Fim's, type 500-999. ===== */

/**
 * Fim part for MS to communicate a topology change to others.
 */
DEFINE_FIM_CLASS_STRUCT(500, TopologyChangeFim, 0) {
  char uuid[40];  /**< Keep UUID hex in the first 36 bytes. Only for DS now */
  union {
    GroupId ds_group; /**< DS group ID if type == 'D' */
    ClientNum client_num; /**< Client number if type == 'F' */
  };
  GroupRole ds_role; /**< DS group role if type == 'D' */
  uint32_t ip;  /**< If joined, the ipv4 address for DS/FC */
  uint16_t port;  /**< If type == 'D' and joined, the port the DS listens on */
  uint16_t pid;  /**< The process ID */
  char type; /**< 'D' = DS, 'F' = FC */
  char joined; /**< '\\x00' = leaving, '\\x01' = joining */
  FIM_STRUCT_END(500, TopologyChangeFim, 0);
};

/**
 * Fim part for MS to communicate DSG state change.
 */
DEFINE_FIM_CLASS_STRUCT(510, DSGStateChangeFim, 0) {
  uint64_t state_change_id; /**< DSG state change id */
  GroupId ds_group; /**< The group having the change */
  GroupRole failed; /**< In case of kDSGDegraded, the role failed */
  uint8_t state; /**< The new state */
  uint8_t ready; /**< Whether the full system is ready */
  uint8_t opt_resync; /**< If kDSGRecovering, whether to optimize resync */
  uint8_t distress; /**< The distress mode, either 0 or 1 */
  FIM_STRUCT_END(510, DSGStateChangeFim, 0);
};

/**
 * Fim part for DS to communicate its knowledge of DSG state change.
 */
DEFINE_FIM_CLASS_STRUCT(511, DSGStateChangeAckFim, 0) {
  uint64_t state_change_id; /**< DSG state change id */
  FIM_STRUCT_END(511, DSGStateChangeAckFim, 0);
};

/**
 * Fim part for MS to communicate distress mode change to DS.
 */
DEFINE_FIM_CLASS_STRUCT(512, DSGDistressModeChangeFim, 0) {
  uint8_t distress; /**< The distress mode, either 0 or 1 */
  FIM_STRUCT_END(512, DSGDistressModeChangeFim, 0);
};

/**
 * Fim part for MS to notify system state change to FC.
 */
DEFINE_FIM_CLASS_STRUCT(520, SysStateNotifyFim, 0) {
  char type; /**< 'D' = DS group, 'M' = MS */
  uint8_t ready; /**< Whether DS group or MS is ready */
  FIM_STRUCT_END(520, SysStateNotifyFim, 0);
};

/**
 * Fim part for the end of reconfirmation.
 */
DEFINE_FIM_CLASS_VOID(530, ReconfirmEndFim, 0);

/**
 * Fim part for MS resync request.  The tail buffer contains inodes
 * removed by the requester before the resync.  Multiple Fims may be
 * sent, where the first and last Fims are marked as such.
 */
DEFINE_FIM_CLASS_STRUCT(540, MSResyncReqFim, 0) {
  char first; /**< Whether to clear previous removals */
  char last; /**< Whether to start actual resync */
  char padding[6]; /**< Make tail buffer 8-byte aligned */
  FIM_STRUCT_END(540, MSResyncReqFim, 0);
};

/**
 * Fim part for MS resync end.
 */
DEFINE_FIM_CLASS_VOID(541, MSResyncEndFim, 0);

/**
 * Fim part for DS resync request.
 */
DEFINE_FIM_CLASS_VOID(550, DSResyncReqFim, 0);

/**
 * Fim part for DS resync end.
 */
DEFINE_FIM_CLASS_VOID(551, DSResyncEndFim, 0);

/**
 * Fim part for shutdown request sent by active MS.
 */
DEFINE_FIM_CLASS_VOID(560, SysShutdownReqFim, 0);

/**
 * Fim part for immediate server termination, sent by active MS.
 */
DEFINE_FIM_CLASS_VOID(561, SysHaltFim, 0);

/**
 * Fim part for requesting file system statistics, sent by FC to MS.
 */
DEFINE_FIM_CLASS_VOID(570, FCStatFSFim, 0);

/**
 * Fim part for replies of successful get file system statistics.
 */
DEFINE_FIM_CLASS_STRUCT(571, FCStatFSReplyFim, kFimFlagReply) {
  uint64_t total_space;  /**< The total space of CPFS */
  uint64_t free_space;  /**< The free space available */
  uint64_t total_inodes;  /**< The total number of inodes */
  uint64_t free_inodes;  /**< The free inodes available */
  FIM_STRUCT_END(571, FCStatFSReplyFim, kFimFlagReply);
};

/**
 * Fim part for requesting file system statistics, sent by MS to DS.
 */
DEFINE_FIM_CLASS_VOID(580, MSStatFSFim, 0);

/**
 * Fim part for replies of successful get file system statistics.
 */
DEFINE_FIM_CLASS_STRUCT(581, MSStatFSReplyFim, kFimFlagReply) {
  uint64_t total_space;  /**< The total space available to DS */
  uint64_t free_space;  /**< The free space available to DS */
  FIM_STRUCT_END(581, MSStatFSReplyFim, kFimFlagReply);
};

/**
 * Fim part for requesting status from cluster nodes
 */
DEFINE_FIM_CLASS_VOID(600, ClusterStatusReqFim, 0);

/**
 * Fim part for replies of cluster node status. The tail buffer stores
 * DS group states and list of node information
 */
DEFINE_FIM_CLASS_STRUCT(610, ClusterStatusReplyFim, kFimFlagReply) {
  uint8_t ms_state;  /**< Active MS state */
  uint8_t ms_role;  /**< Role of the active MS: 1 or 2 */
  uint8_t num_dsg;  /**< Number of DS group info in the tail buffer */
  uint16_t num_node_info;  /**< Number of node info in the tail buffer */
  FIM_STRUCT_END(610, ClusterStatusReplyFim, kFimFlagReply);
};

/**
 * Fim part for requesting DS disk usage info
 */
DEFINE_FIM_CLASS_VOID(620, ClusterDiskInfoReqFim, 0);

/**
 * Fim part for replies of DS disk usage info. The tail buffer stores
 * a list of DSDiskInfo.
 */
DEFINE_FIM_CLASS_VOID(621, ClusterDiskInfoReplyFim, kFimFlagReply);

/**
 * Fim part for requesting config list
 */
DEFINE_FIM_CLASS_VOID(630, ClusterConfigListReqFim, 0);

/**
 * Fim part for replies of DS disk usage info. The tail buffer stores
 * a list of DSDiskInfo.
 */
DEFINE_FIM_CLASS_VOID(631, ClusterConfigListReplyFim, kFimFlagReply);

/**
 * Fim part for requesting config change
 */
DEFINE_FIM_CLASS_STRUCT(640, ClusterConfigChangeReqFim, 0) {
  char target[32];  /**< The target node role to apply */
  char name[32];  /**< The config name to apply */
  char value[256];  /**< The config value to apply */
  FIM_STRUCT_END(640, ClusterConfigChangeReqFim, 0);
};

/**
 * Fim part for replies of DS disk usage info. The tail buffer stores
 * a list of DSDiskInfo.
 */
DEFINE_FIM_CLASS_VOID(641, ClusterConfigChangeReplyFim, kFimFlagReply);

/**
 * Fim part for requesting shutdown of the system
 */
DEFINE_FIM_CLASS_VOID(650, ClusterShutdownReqFim, 0);

/**
 * Fim part for reply of whole system shutdown request
 */
DEFINE_FIM_CLASS_VOID(651, ClusterShutdownReplyFim, kFimFlagReply);

/**
 * Fim part for requesting resize of DS group
 */
DEFINE_FIM_CLASS_STRUCT(660, DSGResizeFim, 0) {
  GroupId num_groups;  /**< Number of DS groups */
  FIM_STRUCT_END(660, DSGResizeFim, 0);
};

/**
 * Fim part for requesting config change from MS for peers
 */
DEFINE_FIM_CLASS_STRUCT(670, PeerConfigChangeReqFim, 0) {
  char name[32];  /**< The config name to apply */
  char value[256];  /**< The config value to apply */
  FIM_STRUCT_END(670, PeerConfigChangeReqFim, 0);
};

/* ===== Fim's for inode maintenance, type 1000-1999. ===== */

/**
 * Fim part for the get file attributes operation.  Replied by
 * AttrReplyFim without group info.
 */
DEFINE_FIM_CLASS_STRUCT(1000, GetattrFim, 0) {
  InodeNum inode; /**< The inode number of the file to get attributes */
  ReqContext context; /**< The context of the operation */
  FIM_STRUCT_END(1000, GetattrFim, 0);
};

/**
 * Fim part for the set file attributes operation.  Replied by
 * AttrReplyFim without group information.
 */
DEFINE_FIM_CLASS_STRUCT(1010, SetattrFim, 0) {
  InodeNum inode; /**< The inode number of the file to set attributes */
  ReqContext context; /**< The context of the operation */
  FileAttr fa; /**< The attributes to set */
  uint32_t fa_mask; /**< Mask specifying which of fa needs to be set */
  char locked; /**< Whether locked setattr is used */
  FIM_STRUCT_END(1010, SetattrFim, 0);
};

/**
 * Fim part for DS inode lock operation.  It can also be used to
 * remove all locks, in which case inode = 0 and lock = '\2'.
 */
DEFINE_FIM_CLASS_STRUCT(1020, DSInodeLockFim, 0) {
  InodeNum inode; /**< The inode number of the file to lock / unlock */
  char lock; /**< '\\0' for unlock, '\\1' for lock, '\\2' for unlock all */
  FIM_STRUCT_END(1020, DSInodeLockFim, 0);
};

/**
 * Fim part for the invalidation operation.
 */
DEFINE_FIM_CLASS_STRUCT(1030, InvInodeFim, 0) {
  InodeNum inode; /**< The inode number to invalidate */
  uint8_t clear_page; /**< Whether page / dentries are to be cleared */
  FIM_STRUCT_END(1030, InvInodeFim, 0);
};

/* ===== Fim's for directory operations, type 2000-2999. ===== */

/**
 * Fim part for the create file operation.  Filename in tail buffer,
 * and must be null-terminated.  DS groups are also in tail buffer,
 * after the filename (occupying the last (sizeof(GroupId) *
 * num_ds_groups) bytes).  This is empty (with num_ds_groups = 0)
 * except for replication requests.  Replied by AttrReplyFim with
 * group information.
 */
DEFINE_FIM_CLASS_STRUCT(2000, CreateFim, 0) {
  InodeNum inode; /**< The inode number of the directory to hold the file */
  ReqContext context; /**< The context of the operation */
  CreateReq req; /**< Details of the file to create */
  uint16_t num_ds_groups; /**< Number of DS groups in request */
  FIM_STRUCT_END(2000, CreateFim, 0);
};

/**
 * Fim part for the unlink file operation.  Filename in tail buffer,
 * and must be null-terminated.
 */
DEFINE_FIM_CLASS_STRUCT(2010, UnlinkFim, 0) {
  InodeNum inode; /**< The inode number of the directory to have file unlink */
  ReqContext context; /**< The context of the operation */
  FIM_STRUCT_END(2010, UnlinkFim, 0);
};

/**
 * Fim part for the lookup file operation.  Filename in tail buffer,
 * and must be null-terminated.  Replied by AttrReplyFim without group
 * information.
 */
DEFINE_FIM_CLASS_STRUCT(2020, LookupFim, 0) {
  InodeNum inode; /**< The inode number of the directory to lookup */
  ReqContext context; /**< The context of the operation */
  FIM_STRUCT_END(2020, LookupFim, 0);
};

/**
 * Fim part for the readdir file operation.  Reply with DataReplyFim,
 * where actual data is in tail buffer.  The data is the concatenation
 * of ReaddirRecord's, without end marker (size of Fim marks the end
 * already).
 */
DEFINE_FIM_CLASS_STRUCT(2030, ReaddirFim, 0) {
  InodeNum inode; /**< The inode number of the file found */
  DentryCookie cookie; /**< Dentry cookie */
  uint32_t size; /**< Maximum size to return */
  FIM_STRUCT_END(2030, ReaddirFim, 0);
};

/**
 * Fim part for new directory creation.  Replied by CreateReplyFim.
 */
DEFINE_FIM_CLASS_STRUCT(2040, MkdirFim, 0) {
  InodeNum parent; /**< The inode number of the parent */
  ReqContext context; /**< The context of the operation */
  CreateDirReq req; /**< Details of the folder to create */
  FIM_STRUCT_END(2040, MkdirFim, 0);
};

/**
 * Fim part for the symlink file operation.  Both filename and link
 * target should be in tail buffer, and both must be null-terminated.
 * The name_len field indicate the length of the name (not counting
 * the null character), so that the link target starts at
 * tail_buf()[name_len + 1].  Replied by CreateReplyFim.
 */
DEFINE_FIM_CLASS_STRUCT(2050, SymlinkFim, 0) {
  InodeNum inode; /**< The inode number of the directory to hold the file */
  ReqContext context; /**< The context of the operation */
  InodeNum new_inode; /**< The inode number of the symlink */
  uint16_t name_len; /**< Length of name of symlink */
  FIM_STRUCT_END(2050, SymlinkFim, 0);
};

/**
 * Fim part for the readlink file operation.  Replied with DataReplyFim.
 */
DEFINE_FIM_CLASS_STRUCT(2060, ReadlinkFim, 0) {
  InodeNum inode; /**< The inode number of the directory to hold the file */
  ReqContext context; /**< The context of the operation */
  FIM_STRUCT_END(2060, ReadlinkFim, 0);
};

/**
 * Fim part for the link file operation.  The name of the new file is
 * in the tail buffer, null terminated.  Replied by AttrReplyFim
 * without group information.
 */
DEFINE_FIM_CLASS_STRUCT(2070, LinkFim, 0) {
  InodeNum inode; /**< The inode number of the file */
  ReqContext context; /**< The context of the operation */
  InodeNum dir_inode; /**< The inode number of the directory of the link */
  FIM_STRUCT_END(2070, LinkFim, 0);
};

/**
 * Fim part for the rename file operation.  The name_len field
 * indicate the length of the name (not counting the null character),
 * so that the target file name starts at tail_buf()[name_len + 1].
 * Reply with ResultCodeReplyFim.
 */
DEFINE_FIM_CLASS_STRUCT(2080, RenameFim, 0) {
  InodeNum new_parent; /**< The inode number of the new parent */
  InodeNum parent; /**< The inode number of the parent of the file */
  ReqContext context; /**< The context of the operation */
  uint32_t name_len; /**< Length of the original filename */
  FIM_STRUCT_END(2080, RenameFim, 0);
};

/**
 * Fim part for the rename file operation.  Name in tail buffer, with
 * '\0' appended.  Reply with ResultCodeReplyFim.
 */
DEFINE_FIM_CLASS_STRUCT(2090, RmdirFim, 0) {
  InodeNum parent; /**< The inode number of the parent of the file */
  ReqContext context; /**< The context of the operation */
  FIM_STRUCT_END(2090, RmdirFim, 0);
};

/**
 * Fim part for the mknod file operation.  The filename should be in
 * tail buffer, and must be null-terminated.  DS groups are also in
 * tail buffer, after the filename (occupying the last
 * (sizeof(GroupId) * num_ds_groups) bytes).  This is empty (with
 * num_ds_groups = 0) except for replication requests.  Replied by
 * CreateReplyFim.
 */
DEFINE_FIM_CLASS_STRUCT(2100, MknodFim, 0) {
  InodeNum inode; /**< The inode number of the directory to hold the file */
  ReqContext context; /**< The context of the operation */
  InodeNum new_inode; /**< The inode number of the node */
  uint64_t mode; /**< File type and mode of the device node to create */
  uint64_t rdev; /**< The device number, in case it is a device */
  uint16_t num_ds_groups; /**< Number of DS groups in request */
  FIM_STRUCT_END(2100, MknodFim, 0);
};

/* ===== Fim's for file operations, type 3000-3999. ===== */

/**
 * Fim part for the open file operation.  Replied with DataReplyFim,
 * containing the group numbers of the file in tail buffer.
 */
DEFINE_FIM_CLASS_STRUCT(3000, OpenFim, 0) {
  InodeNum inode; /**< The inode number of the file to open */
  ReqContext context; /**< The context of the operation */
  int32_t flags;  /**< File open flags */
  FIM_STRUCT_END(3000, OpenFim, 0);
};

/**
 * Fim part for the access file operation.  Replied with
 * ResultCodeReplyFim, containing whether the file access can be
 * granted.
 */
DEFINE_FIM_CLASS_STRUCT(3001, AccessFim, 0) {
  InodeNum inode; /**< The inode number of the file to check access */
  ReqContext context; /**< The context of the operation */
  int32_t mask;  /**< File mask */
  FIM_STRUCT_END(3001, AccessFim, 0);
};

/**
 * Fim part for the write file operation.  Note that this Fim needs
 * special 16-byte alignment for SSE instructions.
 */
DEFINE_FIM_CLASS_STRUCT(3010, WriteFim, 0) {
  InodeNum inode; /**< The inode number of the file to write */
  FSTime optime; /**< The last status change time of the file */
  uint64_t dsg_off; /**< The offset in the DSG to write */
  uint64_t last_off; /**< The last offset of the file being written */
  GroupId target_group; /**< The group ID of the group being read */
  GroupRole target_role; /**< The role in the group being written */
  GroupRole checksum_role; /**< The role in the group for checksum */
  uint8_t padding[12]; /**< Make the whole Fim 16-byte aligned for SSE */
  FIM_STRUCT_END(3010, WriteFim, 0);
};

/**
 * Fim part for the checksum update file operation.  Note that this
 * Fim needs special 16-byte alignment for SSE instructions.
 */
DEFINE_FIM_CLASS_STRUCT(3011, ChecksumUpdateFim, 0) {
  InodeNum inode; /**< The inode number of the file to write */
  FSTime optime; /**< The last status change time of the file */
  uint64_t dsg_off; /**< The offset in the DS to write */
  uint64_t last_off; /**< The last offset of the file being written */
  uint8_t padding[8]; /**< Make the whole Fim 16-byte aligned for SSE */
  FIM_STRUCT_END(3011, ChecksumUpdateFim, 0);
};

/**
 * Fim part for read file operation.  Replied with DataReplyFim.
 */
DEFINE_FIM_CLASS_STRUCT(3020, ReadFim, 0) {
  InodeNum inode; /**< The inode number of the file to read */
  uint64_t dsg_off; /**< The offset in the DSG to read */
  uint32_t size; /**< The number of bytes to read */
  GroupId target_group; /**< The group ID of the group being read */
  GroupRole target_role; /**< The role in the group being read */
  GroupRole checksum_role; /**< The role in the group for checksum */
  FIM_STRUCT_END(3020, ReadFim, 0);
};

/**
 * Fim part for advising MS that file write has taken place on an
 * inode.  MS use the information to extend the file.
 */
DEFINE_FIM_CLASS_STRUCT(3030, AdviseWriteFim, 0) {
  InodeNum inode; /**< The inode number of the file to write */
  ReqContext context; /**< The context of the operation */
  uint64_t off; /**< The last offset of the file being written */
  FIM_STRUCT_END(3030, AdviseWriteFim, 0);
};

/**
 * Fim part for the truncate data operation.
 */
DEFINE_FIM_CLASS_STRUCT(3040, TruncateDataFim, 0) {
  InodeNum inode; /**< The inode number of the file to truncate */
  FSTime optime; /**< The last status change time of the file */
  uint64_t dsg_off; /**< The target size of the file in DSG */
  uint64_t last_off; /**< The target size of the file */
  GroupRole target_role; /**< The role in the group being read */
  GroupRole checksum_role; /**< The role in the group for checksum */
  FIM_STRUCT_END(3040, TruncateDataFim, 0);
};

/**
 * Fim part for decrementing FC's inode open count in MS.  Each open()
 * has one corresponding release().  This Fim is sent only by the last
 * release() call.
 */
DEFINE_FIM_CLASS_STRUCT(3050, ReleaseFim, 0) {
  InodeNum inode; /**< The inode number of the inode */
  char keep_read; /**< Whether the client keeps read permission */
  char clean; /**< Whether nothing has been written since open */
  FIM_STRUCT_END(3050, ReleaseFim, 0);
};

/**
 * Fim part for the free data file operation.
 */
DEFINE_FIM_CLASS_STRUCT(3060, FreeDataFim, 0) {
  InodeNum inode; /**< The inode number of the data file to free */
  FIM_STRUCT_END(3060, FreeDataFim, 0);
};

/**
 * Fim part for the opendir operation.
 */
DEFINE_FIM_CLASS_STRUCT(3070, OpendirFim, 0) {
  InodeNum inode; /**< The inode number of the directory to open */
  ReqContext context; /**< The context of the operation */
  FIM_STRUCT_END(3070, OpendirFim, 0);
};

/**
 * Fim part for updating DS data file mtime.
 */
DEFINE_FIM_CLASS_STRUCT(3080, MtimeUpdateFim, 0) {
  InodeNum inode; /**< The inode number of the file to update */
  FSTime mtime; /**< The new mtime */
  FIM_STRUCT_END(3080, MtimeUpdateFim, 0);
};

/**
 * Fim part for setting xattr. The tail buffer stores the attribute name
 * and value.
 */
DEFINE_FIM_CLASS_STRUCT(3090, SetxattrFim, 0) {
  InodeNum inode; /**< The inode number of the file to set */
  ReqContext context; /**< The context of the operation */
  uint64_t name_len; /**< The length of the attribute name, including '\0' */
  uint64_t value_len; /**< The length of the attribute value */
  uint16_t flags; /**< The flags */
  FIM_STRUCT_END(3090, SetxattrFim, 0);
};

/**
 * Fim part for getting xattr. The tail buffer stores the attribute name
 */
DEFINE_FIM_CLASS_STRUCT(3100, GetxattrFim, 0) {
  InodeNum inode; /**< The inode number of the file to get */
  ReqContext context; /**< The context of the operation */
  uint64_t value_len; /**< The length of the attribute value */
  FIM_STRUCT_END(3100, GetxattrFim, 0);
};

/**
 * Fim part for listing xattr
 */
DEFINE_FIM_CLASS_STRUCT(3110, ListxattrFim, 0) {
  InodeNum inode; /**< The inode number of the file to list */
  ReqContext context; /**< The context of the operation */
  uint32_t size; /**< The length of the list to retrieve */
  FIM_STRUCT_END(3110, ListxattrFim, 0);
};

/**
 * Fim part for removing xattr. The tail buffer stores the attribute name
 */
DEFINE_FIM_CLASS_STRUCT(3120, RemovexattrFim, 0) {
  InodeNum inode; /**< The inode number of the file to list */
  ReqContext context; /**< The context of the operation */
  FIM_STRUCT_END(3120, RemovexattrFim, 0);
};

/* ===== Fim's for file operations, type 10000-10999. ===== */

/**
 * Fim part for final replies.
 */
DEFINE_FIM_CLASS_STRUCT(10000, FinalReplyFim, kFimFlagReply) {
  uint32_t err_no; /**< The error number */
  FIM_STRUCT_END(10000, FinalReplyFim, kFimFlagReply);
};

/**
 * Fim part for replies with a system error.
 */
DEFINE_FIM_CLASS_STRUCT(10001, ResultCodeReplyFim, kFimFlagReply) {
  uint32_t err_no; /**< The error number */
  FIM_STRUCT_END(10001, ResultCodeReplyFim, kFimFlagReply);
};

/**
 * Fim part for replying data.
 */
DEFINE_FIM_CLASS_VOID(10002, DataReplyFim, kFimFlagReply);

/**
 * Fim part for replies of successful get file attributes operation.
 * For plain files, it may contain the group numbers of the file in tail
 * buffer, depending on operations.
 */
DEFINE_FIM_CLASS_STRUCT(10003, AttrReplyFim, kFimFlagReply) {
  InodeNum inode; /**< The inode number being replied */
  FileAttr fa; /**< The file attributes to send to client */
  uint8_t dirty; /**< Whether the attributes may change without invalidation */
  FIM_STRUCT_END(10003, AttrReplyFim, kFimFlagReply);
};

/**
 * Fim part for replies of successful get extended attribute operation.
 * The tail buffer stores the value of the extended attribute
 */
DEFINE_FIM_CLASS_STRUCT(10004, GetxattrReplyFim, kFimFlagReply) {
  uint64_t value_len; /**< The length of extended attribute value returned */
  FIM_STRUCT_END(10004, GetxattrReplyFim, kFimFlagReply);
};

/**
 * Fim part for replies of successful list extended attribute operation.
 * The tail buffer stores the value of the null terminated attribute names
 */
DEFINE_FIM_CLASS_STRUCT(10005, ListxattrReplyFim, kFimFlagReply) {
  uint32_t size; /**< The length of extended attribute value returned */
  FIM_STRUCT_END(10005, ListxattrReplyFim, kFimFlagReply);
};

/* ===== Fim's for MS maintenance operations, type 20000-20999. ===== */

/**
 * Fim part for resync inode file operation.
 */
DEFINE_FIM_CLASS_STRUCT(20000, ResyncInodeFim, 0) {
  InodeNum inode;  /**< The inode number */
  FileAttr fa;  /**< The inode file / folder attribute */
  uint64_t extra_size;  /**< The size of data in tail buffer, excluding xattr */
  FIM_STRUCT_END(20000, ResyncInodeFim, 0);
};

/**
 * Fim part for resync inode dentry operation.
 */
DEFINE_FIM_CLASS_STRUCT(20010, ResyncDentryFim, 0) {
  InodeNum parent;  /**< The inode number of the file */
  InodeNum target;  /**< The target inode number */
  uint32_t uid; /**< The UID of the requestor */
  uint32_t gid; /**< The GID of the requestor */
  unsigned char type; /**< DT_* constant in <dirent.h> */
  FIM_STRUCT_END(20010, ResyncDentryFim, 0);
};

/**
 * Fim part for resync inode removal.
 */
DEFINE_FIM_CLASS_STRUCT(20020, ResyncRemovalFim, 0) {
  InodeNum inode;  /**< The inode number */
  FIM_STRUCT_END(20020, ResyncRemovalFim, 0);
};

/**
 * Fim part for resync dirty inode.
 */
DEFINE_FIM_CLASS_STRUCT(20030, ResyncDirtyInodeFim, 0) {
  InodeNum inode;  /**< The inode number */
  FIM_STRUCT_END(20030, ResyncDirtyInodeFim, 0);
};

/**
 * Fim part for preparation of resync pending unlink, opened inodes etc.
 * The tail buffer stores an array of last used inode values from the '/c'
 */
DEFINE_FIM_CLASS_STRUCT(20040, ResyncInodeUsagePrepFim, 0) {
  FIM_STRUCT_END(20040, ResyncInodeUsagePrepFim, 0);
};

/**
 * Fim part for resync client opened inodes. The tail buffer stores an
 * array of inodes opened by the client, where writable inodes precede
 * non-writable inodes.
 */
DEFINE_FIM_CLASS_STRUCT(20050, ResyncClientOpenedFim, 0) {
  ClientNum client_num; /**< The client number */
  uint32_t num_writable; /**< Number of writable inodes */
  FIM_STRUCT_END(20050, ResyncClientOpenedFim, 0);
};

/**
 * Fim part for resync inode pending for unlink.  The tail buffer
 * stores an array of pending inode numbers.
 */
DEFINE_FIM_CLASS_STRUCT(20060, ResyncPendingUnlinkFim, 0) {
  uint32_t first; /**< Whether this is the first such Fims */
  uint32_t last; /**< Whether this is the last such Fims */
  FIM_STRUCT_END(20060, ResyncPendingUnlinkFim, 0);
};

/**
 * Fim part for resync MS xattr information. The tail buffer stores the
 * extended attribute value
 */
DEFINE_FIM_CLASS_STRUCT(20070, ResyncXattrFim, 0) {
  char name[256]; /**< The name of the extended attribute */
  FIM_STRUCT_END(20070, ResyncXattrFim, 0);
};

/**
 * Fim part for attributes update.
 */
DEFINE_FIM_CLASS_STRUCT(20100, AttrUpdateFim, 0) {
  InodeNum inode; /**< The inode number */
  FIM_STRUCT_END(20100, AttrUpdateFim, 0);
};

/**
 * Fim part for replies of successful attributes update.
 */
DEFINE_FIM_CLASS_STRUCT(20101, AttrUpdateReplyFim, kFimFlagReply) {
  FSTime mtime; /**< mtime of the inode in the DS */
  uint64_t size; /**< file size of the inode in the DS */
  FIM_STRUCT_END(20101, AttrUpdateReplyFim, kFimFlagReply);
};

/* ===== Fim's for DS maintenance operations, type 21000-21999. ===== */

/**
 * Fim part for DS resync file info.  This Fim allows the file
 * information to be resync'ed to the rejoining DS, thus allowing the
 * inode file information to regain fully replicated status.
 */
DEFINE_FIM_CLASS_STRUCT(21000, DSResyncInfoFim, 0) {
  InodeNum inode; /**< The inode number of the file to write */
  FSTime mtime; /**< The mtime of the file as recorded in the DS */
  uint64_t size; /**< Size of the file as recorded in the DS */
  FIM_STRUCT_END(21000, DSResyncInfoFim, 0);
};

/**
 * Fim part for DS resync file contents.
 */
DEFINE_FIM_CLASS_STRUCT(21001, DSResyncFim, 0)  {
  InodeNum inode; /**< The inode number of the file to resync */
  uint64_t cg_off; /**< The DSG offset of the checksum group resync'ed */
  FIM_STRUCT_END(21001, DSResyncFim, 0);
};

/**
 * Fim part for DS resync directory.  The actual contents are InodeNum
 * stored in the tail buffer.  It is processed by failed DS to
 * consolidate a resync list for optimized resync.
 */
DEFINE_FIM_CLASS_VOID(21010, DSResyncDirFim, 0);

/**
 * Fim part for DS resync list request.  DS use it as an indication
 * that it is ready for a new phase of DS data resync, and reply to it
 * a portion of the resync list once it is ready (all DSs have reach
 * the same progress).
 */
DEFINE_FIM_CLASS_VOID(21020, DSResyncListFim, 0);

/**
 * Fim part for DS resync list reply.  Actual inode numbers are stored
 * in the tail buffer.
 */
DEFINE_FIM_CLASS_VOID(21021, DSResyncListReplyFim, kFimFlagReply);

/**
 * Fim part for DS resync inode removal.  Actual inode numbers are
 * stored in the tail buffer.
 */
DEFINE_FIM_CLASS_VOID(21022, DSResyncRemovalFim, 0);

/**
 * Fim part for DS resync ready indication.
 */
DEFINE_FIM_CLASS_VOID(21024, DSResyncReadyFim, 0);

/**
 * Fim part for DS resync ready indication reply.
 */
DEFINE_FIM_CLASS_VOID(21025, DSResyncReadyReplyFim, kFimFlagReply);

}  // namespace cpfs
