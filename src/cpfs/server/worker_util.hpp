#pragma once

/* Copyright 2013 ClusterTech Ltd */

/**
 * @file
 *
 * Define common facilities for worker implementations.
 */

#include <cerrno>
#include <exception>

#include <boost/noncopyable.hpp>
#include <boost/shared_ptr.hpp>

#include "fim.hpp"
#include "fim_socket.hpp"
#include "fims.hpp"

namespace cpfs {
namespace server {

/**
 * Base class for making reply.
 */
class BaseWorkerReplier : boost::noncopyable {
 public:
  /**
   * @param req The request (for finding the ID to reply to).
   *
   * @param peer The peer to send reply to.
   */
  BaseWorkerReplier(const FIM_PTR<IFim>& req,
                    const boost::shared_ptr<IFimSocket>& peer)
      : req_(req), peer_(peer), err_no_(-1), enabled_(true) {}

  /**
   * Set the Fim to reply normally.
   *
   * @param reply The Fim object.
   */
  void SetNormalReply(const FIM_PTR<IFim>& reply) {
    reply_ = reply;
  }

  /**
   * Set the result code, typically of a system call.
   *
   * @param result The result to set.
   */
  void SetResult(int result) {
    if (err_no_ == -1)
      err_no_ = 0;
    if (result < 0)
      err_no_ = -result;
  }

  /**
   * Set whether this replier is enabled or not
   *
   * @param enabled Whether this replier is enabled or not
   */
  void SetEnabled(bool enabled = true) {
    enabled_ = enabled;
  }

  virtual ~BaseWorkerReplier() {}

  /**
   * Make a reply.  No reply is made if this replier is disabled. Typically
   * called by destructor of leaf classes. It makes a call to the abstract
   * ReplyComplete() method, which is why it cannot be called from
   * ~BaseWorkerReplier() (that would call the non-existent
   * BaseWorkerReplier::ReplyComplete()).
   */
  void MakeReply() {
    if (!enabled_)
      return;
    if (std::uncaught_exception())
      err_no_ = EIO;
    if (err_no_ > 0 || !reply_) {
      FIM_PTR<ResultCodeReplyFim> err = ResultCodeReplyFim::MakePtr();
      (*err)->err_no = err_no_ = (err_no_ < 0) ? EIO : err_no_;
      reply_ = err;
    }
    ReplyComplete();
  }

  /**
   * Completion handler.  Must be supplied by subclasses.  It should
   * set reply Fim request id and send it at the appropriate time.
   * When called, the reply_ field is set to the reply created, but
   * its request id is not yet filled.  If a ResultCodeReplyFim is
   * generated by the class, the err_no_ field stores the error
   * number; otherwise the err_no_ field should be 0 or -1 depending
   * on whether SetResult() has been called.
   */
  virtual void ReplyComplete() = 0;

 protected:
  FIM_PTR<IFim> req_; /**< The request */
  boost::shared_ptr<IFimSocket> peer_; /**< The peer sending req_ */
  FIM_PTR<IFim> reply_; /**< The reply */
  int err_no_; /**< Positive errno, -1 indicate SetResult has not been called */
  bool enabled_; /**< Whether the replier is enabled */
};

/**
 * Make an appropriate reply on exit of scope.  To make a successful
 * reply, clients must either call SetNormalReply to set the reply, or
 * make a call SetResult with a non-negative value.  Any call to
 * SetResult with a negative value will cause the reply to be replaced
 * by a ResultCodeReplyFim with err_no being the negation of the last
 * negative value set.  If neither SetNormalReply nor SetResult is
 * called, the a ResultCodeReplyFim with err_no of EIO will be
 * replied.
 */
class ReplyOnExit : public BaseWorkerReplier {
 public:
  /**
   * @param req The request (for finding the ID to reply to).
   *
   * @param peer The peer to send reply to.
   */
  explicit ReplyOnExit(const FIM_PTR<IFim>& req,
                       const boost::shared_ptr<IFimSocket>& peer)
      : BaseWorkerReplier(req, peer) {}

  void ReplyComplete() {
    reply_->set_req_id(req_->req_id());
    reply_->set_final();
    peer_->WriteMsg(reply_);
  }

  ~ReplyOnExit() {
    MakeReply();
  }
};

}  // namespace server
}  // namespace cpfs
